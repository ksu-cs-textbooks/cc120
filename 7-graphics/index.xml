




  
	
	  

  
	
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graphics :: K-State CC 120 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/</link>
    <description>Graphics Bringing visual expression to the web.</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Jun 2024 15:40:07 -0500</lastBuildDate>
    <atom:link href="https://textbooks.cs.ksu.edu/cc120/7-graphics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/01-introduction/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/01-introduction/</guid>
      <description>In computer graphics, we have two primary approaches to representing graphical information, raster and vector representations.&#xA;Raster graphics take their name from the scan pattern of a cathode-ray tube, such as was used in older television sets and computer monitors. These, as well as modern monitors, rely on a regular grid of pixels composed of three colors of light (red, green, and blue) that are mixed at different intensities to create all colors of the visible spectrum.</description>
    </item>
    <item>
      <title>Raster Graphic Files</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/02-raster-graphic-files/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/02-raster-graphic-files/</guid>
      <description>Unsurprisingly, graphic files that store their data in a raster format borrow heavily from the representations discussed previously. Typically, a graphic file consists of two parts, a head and a body. This is very much like how the &lt;head&gt; of a HTML file provides metadata about the page and the &lt;body&gt; contains the actual page contents. For a raster graphic file, the head of the file contains metadata describing the image itself - the color format, along with the width and height of the image.</description>
    </item>
    <item>
      <title>HTML Raster Graphics</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/03-html-raster-graphics/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/03-html-raster-graphics/</guid>
      <description>The most obvious use of raster graphics in HTML is the &lt;img&gt; element, a HTML element that embodies a single raster graphic image. It is defined with the an img tag:&#xA;&lt;img src=&#34;&#34; alt=&#34;&#34;&gt;The src attribute is a relative or absolute url of an image file, and the alt attribute provides a textual description of what the image portrays. It is what the browser displays if the image file does not load, and is also important for screen readers (as discussed in Chapter 6).</description>
    </item>
    <item>
      <title>The Canvas Element</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/04-the-canvas-element/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/04-the-canvas-element/</guid>
      <description>The &lt;canvas&gt; element represents a raster graphic, much like the &lt;img&gt; element. But instead of representing an existing image file, the &lt;canvas&gt; is a blank slate - a grid of pixels on which you can draw using JavaScript. Becuase a canvas doesn’t determine its size from an image file, you need to always declare it with a width and height attribute (otherwise, it has a width and height of 0):</description>
    </item>
    <item>
      <title>The Pen Metaphor</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/05-the-pen-metaphor/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/05-the-pen-metaphor/</guid>
      <description>Most 2D graphics libraries adopt a “pen” metaphor to model how they interact with the graphics they draw. Think of an imaginary pen that you use to draw on the screen. When you put the pen down and move it across the screen you draw a line - the stroke. When you lift the pen, you no longer make a mark. The movements of the pen across the canvas also define a path.</description>
    </item>
    <item>
      <title>Stroke and Fill</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/06-stroke-and-fill/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/06-stroke-and-fill/</guid>
      <description>The stroke and fill work with the current path of the context, defining how the outline and interior of a shape defined by the path are drawn.&#xA;Stroke The stroke() draws all of the path segments where the pen was “down”. The appearance of the stroke can be altered with specific properties of the canvas:&#xA;strokeStyle allows you to set the color of the stroke, i.e. ctx.strokeStyle = &#39;orange&#39;;. You can use one of the named colors, i.</description>
    </item>
    <item>
      <title>Shape Functions</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/07-shape-functions/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/07-shape-functions/</guid>
      <description>For ease of use, the context also supplies a number of functions for drawing shapes. Some of these just define the shape as a series of subpaths to be used with the stroke() and fill() functions.&#xA;Arcs and Circles Of these, we’ve already seen the arc(x, y, radius, startAngle, endAngle) function. It can be used to draw an arc, or when filled, a wedge - like a pie slice. When a startAngle of 0 and endAngle of 2 * Math.</description>
    </item>
    <item>
      <title>Canvas Text</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/08-canvas-text/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/08-canvas-text/</guid>
      <description>While the canvas is primarily used to draw graphics, there are times we want to use text as well. We have two methods to draw text: fillText(text, x, y) and strokeText(text, x, y). The text parameter is the text to render, and the x and y are the upper left corner of the text.&#xA;As with the fillRect() and strokeRect() functions, fillText() and strokeText() fill and stroke the text, respectively, and the text does not affect the current path.</description>
    </item>
    <item>
      <title>Canvas and Images</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/09-canvas-images/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/09-canvas-images/</guid>
      <description>The &lt;canvas&gt; and &lt;img&gt; elements are both raster representations of graphics, which introduces an interesting possibility - copying the data of an image into the canvas. This can be done with the drawImage() family of functions.&#xA;The first of these is drawImage(image, x, y). This copies the entire image held in the image variable onto the canvas, starting at (x, y).&#xA;&lt;canvas id=&#34;image-example-1&#34; width=&#34;500&#34; height=&#34;300&#34;&gt;&lt;/canvas&gt; &lt;script&gt; var canvas1 = document.getElementById(&#39;image-example-1&#39;); var ctx1 = canvas1.</description>
    </item>
    <item>
      <title>Transforms and State</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/10-canvas-transforms/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/10-canvas-transforms/</guid>
      <description>Much like we can use CSS to apply transformations to HTML elements, we can use transforms to change how we draw into a canvas. The rendering context has a transformation matrix much like those we discussed in the CSS chapter, and it applies this transform to any point it is tasked with drawing.&#xA;We can replace the current transformation matrix with the setTransform() function, or multiply it by a new transformation (effectively combining the current transformation with the new one) by calling transform().</description>
    </item>
    <item>
      <title>Animation</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/11-canvas-animation/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/11-canvas-animation/</guid>
      <description>The canvas element provides a powerful tool for creating animations by allowing us to erase and re-draw its contents over and over. Ideally, we only want to redraw the canvas contents only as quickly as the screen is updated (typically every 1/30th or 1/60th of a second). The window.requestAnimationFrame(callback) provides an approach for doing this - it triggers the supplied callback every time the monitor refreshes.&#xA;Inside that callback, we want to erase the canvas and then draw the updated scene.</description>
    </item>
    <item>
      <title>Vector Graphics</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/12-vector-graphics/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/12-vector-graphics/</guid>
      <description>Up to this point, we’ve been discussing raster graphics, which are represented by a grid of pixels. In contrast, vector graphics are stored as a series of instructions to re-create the graphic. For most vector approaches, these instructions look similar to those we issued to our JavaScript rendering context when working with the &lt;canvas&gt; element - including the idea of paths, stroke, and fill.&#xA;The vector approach has its own benefits and drawbacks when compared to raster graphics.</description>
    </item>
    <item>
      <title>SVG</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/13-svg/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/13-svg/</guid>
      <description>The Scalable Vector Graphics (SVG) image format is a file format for creating a vector graphic. It uses the same ideas about path, stroke, and fill and coordinate that we discussed with the canvas. It also is a text format based on XML, as was HTML. So the contents of a XML file will look familiar to you. Here is an example:&#xA;&lt;svg viewBox=&#34;0 0 500 200&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34;&gt; &lt;path d=&#34;M 100 50 L 100 150 L 300 150 Z&#34; stroke=&#34;black&#34; fill=&#34;#dd3333&#34;/&gt; &lt;/svg&gt;Let’s take a close look at the file format.</description>
    </item>
    <item>
      <title>SVG Paths</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/14-svg-paths/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/14-svg-paths/</guid>
      <description>SVGs use the same pen metaphor we saw with the &lt;canvas&gt; and one of the most basic approaches to drawing in an SVG is the &lt;path&gt; element. Each &lt;path&gt; should contain a d attribute, which holds the commands used to draw the path. These are very similar to the commands we used with the &lt;canvas&gt; and the CanvasRenderingContext2D we used earlier, but instead of being written as a function call, they are written as a capital letter (indicating what command to carry out) followed by numbers specifying the action.</description>
    </item>
    <item>
      <title>SVG Shapes</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/15-svg-shapes/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/15-svg-shapes/</guid>
      <description>Much like the CanvasRenderingContext2d we used with the &lt;canvas&gt; earlier allowed us to render rectangles outside of the path, the SVG format also provides mechanisms for rendering common shapes. These are specified using their own tags (like HTML elements), and there are a wide variety of shapes available:&#xA;Rectangle The &lt;rect&gt; element defines a rectangle, specified by the now-familiar x, y,, width and height attributes, and with optional rounded corners with radius specified by the rx attribute.</description>
    </item>
    <item>
      <title>SVG Animation</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/17-svg-animation/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/17-svg-animation/</guid>
      <description>SVG has several build-in approaches to add animation to a drawing, the &lt;animate&gt; and &lt;animateMotion&gt; elements.&#xA;The &lt;animate&gt; Element The &lt;animate&gt; element is used to animate the attributes of an element over time. It must be declared as a child of the element it will animate, i.e.:&#xA;&lt;svg viewBox=&#34;0 0 100 100&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; height=&#34;200&#34;&gt; &lt;circle cx=&#34;50&#34; cy=&#34;50&#34; r=&#34;50&#34; fill=&#34;cornflowerblue&#34;&gt; &lt;animate attributeName=&#34;r&#34; values=&#34;10;50;20;50;10&#34; dur=&#34;10s&#34; repeatCount=&#34;indefinite&#34;/&gt; &lt;/circle&gt; &lt;/svg&gt;Here we have a 10 second duration repeating animation that alters the radius of a circle between a number of different values.</description>
    </item>
    <item>
      <title>SVG Transforms</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/16-svg-transforms/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/16-svg-transforms/</guid>
      <description>As with CSS and the canvas, SVGs also support transformations. In an SVG, these are specified by the transform attribute and thus apply to a specific element. For example, to rotate our ellipse from the previous section by 15 degrees around its center, we would use:&#xA;&lt;svg viewBox=&#34;0 0 200 100&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; height=&#34;200&#34;&gt; &lt;ellipse cx=&#34;100&#34; cy=&#34;50&#34; rx=&#34;100&#34; ry=&#34;50&#34; fill=&#34;cornflowerblue&#34; transform=&#34;rotate(15 100 50)&#34;/&gt; &lt;/svg&gt;Notice how the ellipse is clipped at the view box - this is another important role the view box plays.</description>
    </item>
    <item>
      <title>SVG and CSS</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/19-svg-and-css/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/19-svg-and-css/</guid>
      <description>When using inline SVG, you can apply CSS to the SVG using any of the methods we’ve used with HTML - inline styles, the &lt;style&gt; element, or a CSS file. The rules work exactly the same - you select a SVG element using a CSS selector, and apply style rules. SVG elements have tag name, and can also specify id and class attributes just like HTML. For example:&#xA;&lt;style&gt; rect { fill: purple; stroke: black; stroke-width: 5; } #my-circle { fill: violet; stroke: #333; } &lt;/style&gt; &lt;svg viewBox=&#34;0 0 300 100&#34; xmlns=&#34;http://www.</description>
    </item>
    <item>
      <title>SVG and HTML</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/18-svg-and-html/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/18-svg-and-html/</guid>
      <description>As described earlier, SVG is an image file format. Thus, it can be used as the src for an &lt;img&gt; element in HTML:&#xA;&lt;img src=&#34;https://textbooks.cs.ksu.edu/cc120/images/triangle.svg&#34; alt=&#34;A triangle&#34;&gt;However, the SVG itself is just text. And that text shares a lot of characteristics with HTML, as both are derived from XML. As SVG became more commonplace, the W3C added support for inline SVGs - placing SVG code directly in a HTML document:</description>
    </item>
    <item>
      <title>SVG and JavaScript</title>
      <link>https://textbooks.cs.ksu.edu/cc120/7-graphics/20-svg-and-js/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc120/7-graphics/20-svg-and-js/</guid>
      <description>Likewise, inline SVG elements are part of the DOM tree, and can be manipulated with JavaScript in almost the same way as any HTML element. You can retrieve a SVG node with the various query methods: document.getElementsByName(name), document.getElementById(id), document.getElementsByClassName(className), document.querySelector(), and document.querySelectorAll(selector). This works just like it does with HTML elements.&#xA;However, to work with the attributes of a SVG element, you must use the setAttributeNS(ns, attr) and getAttributeNS(ns, attr) respectively, as the SVG attributes are part of the SVG namespace, not the HTML (default) namespace.</description>
    </item>
  </channel>
</rss>